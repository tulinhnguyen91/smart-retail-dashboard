# -*- coding: utf-8 -*-
"""models/lstm_model

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lATLlqDmcPV8I1WAucwk9lxPz0GPOdUn
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from utils.metrics import mean_absolute_percentage_error # Import custom MAPE

def create_sequences(data, seq_length=30):
    """
    Tạo các chuỗi dữ liệu cho mô hình LSTM.

    Args:
        data (np.array): Dữ liệu đầu vào (thường là dữ liệu đã được scale).
        seq_length (int): Độ dài của mỗi chuỗi.

    Returns:
        tuple: (np.array, np.array) - X (features) và y (target).
    """
    X, y = [], []
    for i in range(len(data) - seq_length):
        X.append(data[i:i+seq_length])
        y.append(data[i+seq_length])
    return np.array(X), np.array(y)

def run_lstm_forecast(df_final, product_name, seq_len=30, epochs=20, batch_size=32):
    """
    Thực hiện pipeline dự báo LSTM cho một sản phẩm cụ thể.

    Args:
        df_final (pd.DataFrame): DataFrame chứa toàn bộ dữ liệu đã được xử lý.
        product_name (str): Tên sản phẩm cần dự báo.
        seq_len (int): Độ dài của chuỗi đầu vào cho LSTM.
        epochs (int): Số epoch để huấn luyện mô hình.
        batch_size (int): Kích thước batch để huấn luyện mô hình.

    Returns:
        tuple: (matplotlib.figure.Figure, pd.DataFrame)
               Figure của biểu đồ dự báo, và DataFrame chứa kết quả dự báo.
               Trả về (None, None) nếu không đủ dữ liệu.
    """
    print(f"\n--- Running LSTM for product: '{product_name}' ---")

    df = df_final[df_final['Product_Name'] == product_name].copy()

    if df.empty:
        print(f"  Warning: Data for '{product_name}' is empty. Skipping LSTM.")
        return None, None

    # --- 3.2. Data Preparation for LSTM ---
    df['Date'] = pd.to_datetime(df['Date'])
    df = df.sort_values('Date').reset_index(drop=True)

    df_daily = df.groupby('Date')['Quantity_Sold'].sum().reset_index()
    df_daily = df_daily.set_index('Date').sort_index().copy()

    # --- 3.3. Normalize and Prepare Sequences ---
    scaler = MinMaxScaler(feature_range=(0, 1))
    scaled_data = scaler.fit_transform(df_daily[['Quantity_Sold']])

    if len(scaled_data) < seq_len + 1:
        print(f"  Warning: Not enough data points ({len(scaled_data)}) for '{product_name}' to create sequences of length {seq_len}. Skipping LSTM.")
        return None, None

    X, y = create_sequences(scaled_data, seq_len)

    # --- 3.4. Data Split ---
    split = int(0.8 * len(X))

    if split == 0 or split == len(X) or len(X_train) == 0 or len(X_test) == 0:
        print(f"  Warning: Not enough sequences ({len(X)}) for '{product_name}' to create meaningful train/test sets. Skipping LSTM.")
        return None, None

    X_train, X_test = X[:split], X[split:]
    y_train, y_test = y[:split], y[split:]

    # Reshape for LSTM input: [samples, time_steps, features]
    X_train = X_train.reshape(X_train.shape[0], X_train.shape[1], 1)
    X_test = X_test.reshape(X_test.shape[0], X_test.shape[1], 1)

    # --- 3.5. Model Building ---
    model = Sequential()
    model.add(LSTM(64, return_sequences=True, input_shape=(X_train.shape[1], 1)))
    model.add(Dropout(0.2))
    model.add(LSTM(32))
    model.add(Dropout(0.2))
    model.add(Dense(1))

    model.compile(optimizer='adam', loss='mean_squared_error')

    # --- 3.6. Train Model ---
    try:
        model.fit(X_train, y_train, epochs=epochs, batch_size=batch_size, validation_split=0.1, verbose=0) # verbose=0 to suppress output
    except Exception as e:
        print(f"  Error training LSTM model for '{product_name}': {e}")
        return None, None

    # --- 3.7. Performance Evaluation & Visualize ---
    y_pred_scaled = model.predict(X_test)
    y_pred = scaler.inverse_transform(y_pred_scaled)
    y_test_inv = scaler.inverse_transform(y_test)

    mae = mean_absolute_error(y_test_inv, y_pred)
    rmse = np.sqrt(mean_squared_error(y_test_inv, y_pred))
    mape = mean_absolute_percentage_error(y_test_inv, y_pred)
    r2 = r2_score(y_test_inv, y_pred)

    print(f"  Test Set Performance for '{product_name}':")
    print(f"    MAE: {mae:.2f}")
    print(f"    RMSE: {rmse:.2f}")
    print(f"    MAPE: {mape:.2f}%")
    print(f"    R²: {r2:.2f}")

    # --- Forecasting future (e.g., next 30 days beyond test set) ---
    # This is a basic iterative forecast. For production, consider more robust methods.
    last_sequence = scaled_data[-seq_len:].reshape(1, seq_len, 1)
    future_forecast = []
    num_future_steps = 30 # Forecast for next 30 days

    for _ in range(num_future_steps):
        next_pred_scaled = model.predict(last_sequence)[0,0]
        future_forecast.append(next_pred_scaled)
        # Update the sequence: remove first element, add new prediction
        last_sequence = np.append(last_sequence[:,1:,:], [[next_pred_scaled]]).reshape(1, seq_len, 1)

    future_forecast_inv = scaler.inverse_transform(np.array(future_forecast).reshape(-1, 1))
    future_dates = pd.date_range(start=df_daily.index.max() + pd.Timedelta(days=1), periods=num_future_steps, freq='D')
    forecast_results_df = pd.DataFrame(future_forecast_inv, index=future_dates, columns=['Forecasted_Quantity_Sold'])
    forecast_results_df['Forecasted_Quantity_Sold'] = forecast_results_df['Forecasted_Quantity_Sold'].apply(lambda x: max(0, x)) # No negative values

    # --- Visualization ---
    fig, ax = plt.subplots(figsize=(14, 7))
    ax.plot(df_daily.index, df_daily['Quantity_Sold'], label='Actual Sales (Historical)')

    # Plot test set predictions (aligning with original dates)
    # Need to get the dates corresponding to the test set
    test_dates = df_daily.index[len(df_daily) - len(y_test_inv):]
    ax.plot(test_dates, y_pred, '--', label='Predicted Sales (Test Set)')
    ax.plot(forecast_results_df.index, forecast_results_df['Forecasted_Quantity_Sold'], 'r-', label=f'Forecasted Sales (Next {num_future_steps} Days)')

    ax.set_title(f"LSTM Forecast vs Actual Sales for '{product_name}'")
    ax.set_xlabel("Date")
    ax.set_ylabel("Quantity Sold")
    ax.legend()
    ax.grid(True, linestyle='--', alpha=0.6)
    plt.tight_layout()

    return fig, forecast_results_df
