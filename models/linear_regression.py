# -*- coding: utf-8 -*-
"""models/linear_regression

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19lWH2Aw4inqeP4eNFzCTPM3DiG60cuRR
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from utils.metrics import mean_absolute_percentage_error # Import custom MAPE

def run_linear_regression_forecast(df_final, product_name):
    """
    Thực hiện pipeline dự báo Linear Regression cho một sản phẩm cụ thể,
    bao gồm chuẩn bị dữ liệu, kỹ thuật đặc trưng, huấn luyện, đánh giá và dự báo 2025.

    Args:
        df_final (pd.DataFrame): DataFrame chứa toàn bộ dữ liệu đã được xử lý.
        product_name (str): Tên sản phẩm cần dự báo.

    Returns:
        tuple: (matplotlib.figure.Figure, pd.DataFrame)
               Figure của biểu đồ dự báo, và DataFrame chứa kết quả dự báo 2025.
               Trả về (None, None) nếu không đủ dữ liệu.
    """
    print(f"\n--- Running Linear Regression for product: '{product_name}' ---")

    df = df_final[df_final['Product_Name'] == product_name].copy()

    if df.empty:
        print(f"  Warning: Data for '{product_name}' is empty. Skipping Linear Regression.")
        return None, None

    # --- 1.1. Data Preparation ---
    df['Date'] = pd.to_datetime(df['Date'])
    df = df.sort_values('Date').set_index('Date')

    daily = df.resample('D').agg({
        'Quantity_Sold':'sum',
        'Price':'mean',
        'Stock_Level':'sum',
        'Reorder_Threshold':'mean',
        'Promo_Budget':'sum',
        'Store_Size':'mean',
        'Promo_Type_Code':'mean'
    }).rename(columns={
        'Price':'Avg_Price',
        'Stock_Level':'Total_Stock',
        'Reorder_Threshold':'Avg_Reorder_Threshold',
        'Promo_Budget':'Total_Budget',
        'Store_Size':'Avg_Store_Size',
        'Promo_Type_Code':'Avg_Promo_Code'
    }).copy()

    daily.fillna({
        'Quantity_Sold': 0,
        'Total_Stock': 0,
        'Total_Budget': 0
    }, inplace=True)

    for col in ['Avg_Price','Avg_Reorder_Threshold','Avg_Store_Size','Avg_Promo_Code']:
        daily[col].fillna(method='ffill', inplace=True)
        daily[col].fillna(0, inplace=True)

    # --- 1.2. Feature Engineering for Modeling ---
    daily['t'] = np.arange(len(daily))

    for p in [7,14,30,90,365]:
        daily[f'sin{p}'] = np.sin(2*np.pi*daily['t']/p)
        daily[f'cos{p}'] = np.cos(2*np.pi*daily['t']/p)

    for lag in [1,2,3,7,14,30]:
        daily[f'lag_{lag}'] = daily['Quantity_Sold'].shift(lag).fillna(0)

    for w in [3,7,14,30]:
        daily[f'roll_{w}'] = daily['Quantity_Sold'].shift(1).rolling(w).mean().fillna(0)

    daily['dow'] = daily.index.dayofweek
    daily['month'] = daily.index.month

    daily = pd.concat([
        daily,
        pd.get_dummies(daily['dow'], prefix='dow'),
        pd.get_dummies(daily['month'], prefix='mon')
    ], axis=1).copy()

    # --- 1.3. Feature Selection and Dataset Splitting ---
    features = ['t'] + \
               [f'sin{p}' for p in [7,14,30,90,365]] + \
               [f'cos{p}' for p in [7,14,30,90,365]] + \
               ['Avg_Price','Total_Stock','Avg_Reorder_Threshold','Total_Budget','Avg_Store_Size','Avg_Promo_Code'] + \
               [f'lag_{l}' for l in [1,2,3,7,14,30]] + \
               [f'roll_{w}' for w in [3,7,14,30]] + \
               [c for c in daily.columns if c.startswith('dow_') or c.startswith('mon_')]

    features = [f for f in features if f in daily.columns]

    daily.dropna(subset=features + ['Quantity_Sold'], inplace=True)

    if daily.empty or len(daily) < len(features) + 2 or len(daily) < 2:
        print(f"  Warning: Not enough clean data for '{product_name}' after feature engineering/dropna. Skipping model training.")
        return None, None

    X = daily[features].copy()
    y = daily['Quantity_Sold'].copy()

    split = int(len(X)*0.8)
    if split == 0 or split == len(X) or split < 2 or (len(X) - split) < 2:
        print(f"  Warning: Not enough data for '{product_name}' to create meaningful train/test sets. Skipping model training.")
        return None, None

    X_train, X_test = X[:split], X[split:]
    y_train, y_test = y[:split], y[split:]

    # --- 1.4. Data Scaling and Model Training ---
    scaler = StandardScaler()
    X_train_s = scaler.fit_transform(X_train)
    X_test_s = scaler.transform(X_test)

    model = LinearRegression()
    model.fit(X_train_s, y_train)

    y_pred = model.predict(X_test_s)

    # --- 1.5. Performance Evaluation ---
    mae = mean_absolute_error(y_test, y_pred)
    rmse = np.sqrt(mean_squared_error(y_test, y_pred))
    mape = mean_absolute_percentage_error(y_test, y_pred)
    r2 = r2_score(y_test, y_pred)

    print(f"  Test Set Performance for {product_name}:\n"
          f"    MAE  = {mae:.2f}\n"
          f"    RMSE = {rmse:.2f}\n"
          f"    MAPE = {mape:.2f}%\n"
          f"    R2   = {r2:.3f}")

    # --- 1.6. Forecasting Sales for 2025 ---
    last_date_in_data = daily.index.max()
    forecast_start_date = pd.to_datetime('2025-01-01')
    forecast_end_date = pd.to_datetime('2025-12-31')

    if last_date_in_data >= forecast_end_date:
        print(f"  Warning: Data for '{product_name}' already covers or exceeds 2025. Forecast might be redundant.")
        forecast_results = pd.DataFrame() # No new forecast needed
    elif last_date_in_data.year >= 2025:
        forecast_start_date = last_date_in_data + pd.Timedelta(days=1)

    if forecast_start_date > forecast_end_date:
        print(f"  Warning: Forecast start date {forecast_start_date.strftime('%Y-%m-%d')} is after forecast end date {forecast_end_date.strftime('%Y-%m-%d')}. Skipping 2025 forecast.")
        forecast_results = pd.DataFrame()
    else:
        forecast_dates = pd.date_range(start=forecast_start_date, end=forecast_end_date, freq='D')
        forecast_df = pd.DataFrame(index=forecast_dates)

        for col in ['Avg_Price', 'Avg_Reorder_Threshold', 'Avg_Store_Size', 'Avg_Promo_Code']:
            if col in daily.columns:
                forecast_df[col] = daily[col].iloc[-1]
            else:
                forecast_df[col] = 0

        if 'Total_Stock' in daily.columns:
            forecast_df['Total_Stock'] = daily['Total_Stock'].iloc[-1]
        else:
            forecast_df['Total_Stock'] = 0

        if 'Total_Budget' in daily.columns:
            forecast_df['Total_Budget'] = daily['Total_Budget'].iloc[-1]
        else:
            forecast_df['Total_Budget'] = 0

        last_t_value = X['t'].max()
        forecast_df['t'] = np.arange(last_t_value + 1, last_t_value + 1 + len(forecast_df))

        for p in [7,14,30,90,365]:
            forecast_df[f'sin{p}'] = np.sin(2*np.pi*forecast_df['t']/p)
            forecast_df[f'cos{p}'] = np.cos(2*np.pi*forecast_df['t']/p)

        forecast_df['dow'] = forecast_df.index.dayofweek
        forecast_df['month'] = forecast_df.index.month

        dow_dummies_forecast = pd.get_dummies(forecast_df['dow'], prefix='dow')
        mon_dummies_forecast = pd.get_dummies(forecast_df['month'], prefix='mon')

        for col in [c for c in X_train.columns if c.startswith('dow_')]:
            if col not in dow_dummies_forecast.columns:
                dow_dummies_forecast[col] = 0
        for col in [c for c in X_train.columns if c.startswith('mon_')]:
            if col not in mon_dummies_forecast.columns:
                mon_dummies_forecast[col] = 0

        forecast_df = pd.concat([forecast_df, dow_dummies_forecast, mon_dummies_forecast], axis=1).copy()

        for lag in [1,2,3,7,14,30]:
            lag_col_name = f'lag_{lag}'
            if lag_col_name in features:
                if len(daily['Quantity_Sold']) >= lag:
                    forecast_df[lag_col_name] = daily['Quantity_Sold'].iloc[-lag]
                else:
                    forecast_df[lag_col_name] = 0

        for w in [3,7,14,30]:
            roll_col_name = f'roll_{w}'
            if roll_col_name in features:
                if len(daily['Quantity_Sold']) >= w + 1:
                    forecast_df[roll_col_name] = daily['Quantity_Sold'].rolling(w).mean().iloc[-1]
                else:
                    forecast_df[roll_col_name] = 0

        # Ensure columns match training features
        X_forecast = forecast_df[features].copy()
        X_forecast_s = scaler.transform(X_forecast)

        y_forecast_2025 = model.predict(X_forecast_s)
        y_forecast_2025[y_forecast_2025 < 0] = 0 # Ensure no negative forecasts

        forecast_results = pd.DataFrame(y_forecast_2025, index=forecast_dates, columns=['Forecasted_Quantity_Sold'])

    # --- Visualization ---
    fig, ax = plt.subplots(figsize=(14, 7))
    ax.plot(daily.index, daily['Quantity_Sold'], label='Doanh số thực tế (Lịch sử)')
    ax.plot(daily.index[daily.index.isin(X_test.index)], y_pred, '--', label='Dự báo tuyến tính (Tập kiểm tra)')
    if not forecast_results.empty:
        ax.plot(forecast_results.index, forecast_results['Forecasted_Quantity_Sold'], 'r-', label='Doanh số dự báo 2025')
    ax.set_title(f'Dự báo doanh số cho {product_name} (Lịch sử, Kiểm tra và Dự báo 2025)')
    ax.set_xlabel('Ngày')
    ax.set_ylabel('Số lượng bán')
    ax.legend()
    ax.grid(True, linestyle='--', alpha=0.6)
    plt.tight_layout()

    return fig, forecast_results
