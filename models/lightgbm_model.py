# -*- coding: utf-8 -*-
"""models/lightgbm_model

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MfVqPdqWalpvF5wuru6nTOTgyDBw7UMO
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import TimeSeriesSplit, GridSearchCV
from sklearn.pipeline import Pipeline
from lightgbm import LGBMRegressor
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from utils.metrics import mean_absolute_percentage_error # Import custom MAPE

def run_lightgbm_forecast(df_final, product_name):
    """
    Thực hiện pipeline dự báo LightGBM cho một sản phẩm cụ thể,
    bao gồm chuẩn bị dữ liệu, kỹ thuật đặc trưng, huấn luyện, đánh giá và dự báo.

    Args:
        df_final (pd.DataFrame): DataFrame chứa toàn bộ dữ liệu đã được xử lý.
        product_name (str): Tên sản phẩm cần dự báo.

    Returns:
        tuple: (matplotlib.figure.Figure, pd.DataFrame)
               Figure của biểu đồ dự báo, và DataFrame chứa kết quả dự báo.
               Trả về (None, None) nếu không đủ dữ liệu.
    """
    print(f"\n--- Running LightGBM for product: '{product_name}' ---")

    df = df_final[df_final['Product_Name'] == product_name].copy()

    if df.empty:
        print(f"  Warning: Data for '{product_name}' is empty. Skipping LightGBM.")
        return None, None

    # --- 4.1. Data Preparation for LightGBM ---
    df['Date'] = pd.to_datetime(df['Date'])
    df = df.sort_values('Date').set_index('Date')

    daily = df.resample('D').agg({
        'Quantity_Sold':'sum',
        'Price':'mean',
        'Stock_Level':'sum',
        'Reorder_Threshold':'mean',
        'Promo_Budget':'sum',
        'Store_Size':'mean',
        'Promo_Type_Code':'mean'
    }).rename(columns={
        'Price':'Avg_Price',
        'Stock_Level':'Total_Stock',
        'Reorder_Threshold':'Avg_Reorder_Threshold',
        'Promo_Budget':'Total_Budget',
        'Store_Size':'Avg_Store_Size',
        'Promo_Type_Code':'Avg_Promo_Code'
    }).copy()

    daily.fillna({
        'Quantity_Sold': 0,
        'Total_Stock': 0,
        'Total_Budget': 0
    }, inplace=True)

    for col in ['Avg_Price','Avg_Reorder_Threshold','Avg_Store_Size','Avg_Promo_Code']:
        daily[col].fillna(method='ffill', inplace=True)
        daily[col].fillna(0, inplace=True)

    if daily.empty:
        print(f"  Warning: Daily aggregated data for '{product_name}' is empty. Skipping LightGBM.")
        return None, None

    # --- 4.2. Feature Engineering for LightGBM ---
    daily['t'] = np.arange(len(daily))
    daily['sin7'] = np.sin(2 * np.pi * daily['t'] / 7)
    daily['cos7'] = np.cos(2 * np.pi * daily['t'] / 7)
    daily['sin30'] = np.sin(2 * np.pi * daily['t'] / 30)
    daily['cos30'] = np.cos(2 * np.pi * daily['t'] / 30)

    for lag in [1,7,14,30]:
        daily[f'lag_{lag}'] = daily['Quantity_Sold'].shift(lag).fillna(0)

    for win in [7,14,30]:
        daily[f'roll_{win}'] = daily['Quantity_Sold'].shift(1).rolling(win).mean().fillna(0)

    daily['dow'] = daily.index.dayofweek
    daily['month'] = daily.index.month

    dow_d = pd.get_dummies(daily['dow'], prefix='dow')
    mon_d = pd.get_dummies(daily['month'], prefix='mon')
    daily = daily.join(dow_d).join(mon_d).copy()

    # --- 4.3. Feature Selection and Data Split ---
    features = [
        't','sin7','cos7','sin30','cos30',
        'Avg_Price','Total_Stock','Avg_Reorder_Threshold',
        'Total_Budget','Avg_Store_Size','Avg_Promo_Code'
    ] + [f'lag_{lag}' for lag in [1,7,14,30]] + [f'roll_{win}' for win in [7,14,30]] + \
      [c for c in daily.columns if c.startswith('dow_') or c.startswith('mon_')]

    features = [f for f in features if f in daily.columns]

    daily.dropna(subset=features+['Quantity_Sold'], inplace=True)

    if daily.empty or len(daily) < len(features) + 2 or len(daily) < 2:
        print(f"  Warning: Not enough clean data for '{product_name}' after feature engineering/dropna. Skipping model training.")
        return None, None

    X = daily[features].copy()
    y = daily['Quantity_Sold'].copy()

    split = int(len(daily)*0.8)

    if split == 0 or split == len(X) or split < 2 or (len(X) - split) < 2:
        print(f"  Warning: Not enough data ({len(X)} rows) for '{product_name}' to create meaningful train/test sets. Skipping LightGBM.")
        return None, None

    X_train, X_test = X.iloc[:split], X.iloc[split:]
    y_train, y_test = y.iloc[:split], y.iloc[split:]

    # --- 4.4. Model Training ---
    tscv = TimeSeriesSplit(n_splits=5)

    pipeline = Pipeline([
        ('scale', StandardScaler()),
        ('lgbm', LGBMRegressor(random_state=42))
    ])

    param_grid = {
        'lgbm__n_estimators': [100, 200],
        'lgbm__max_depth': [5, 10],
        'lgbm__learning_rate': [0.01, 0.1]
    }

    try:
        search = GridSearchCV(pipeline, param_grid, cv=tscv, scoring='neg_mean_absolute_percentage_error', n_jobs=-1)
        search.fit(X_train, y_train)
        best_model = search.best_estimator_
        print(f"  Best LightGBM parameters for '{product_name}': {search.best_params_}")
    except Exception as e:
        print(f"  Error during LightGBM GridSearchCV for '{product_name}': {e}")
        return None, None

    # --- 4.5. Model Evaluation ---
    y_pred = best_model.predict(X_test)

    mae = mean_absolute_error(y_test, y_pred)
    rmse = np.sqrt(mean_squared_error(y_test, y_pred))
    mape = mean_absolute_percentage_error(y_test, y_pred)
    r2 = r2_score(y_test, y_pred)

    print(f"  Test Set Performance for '{product_name}':\n"
          f"    MAE  = {mae:.2f}\n"
          f"    RMSE = {rmse:.2f}\n"
          f"    MAPE = {mape:.2f}%\n"
          f"    R²   = {r2:.3f}")

    # --- Forecasting 2025 ---
    last_date_in_data = daily.index.max()
    forecast_start_date = pd.to_datetime('2025-01-01')
    forecast_end_date = pd.to_datetime('2025-12-31')

    if last_date_in_data >= forecast_end_date:
        print(f"  Warning: Data for '{product_name}' already covers or exceeds 2025. Forecast might be redundant.")
        forecast_results = pd.DataFrame()
    elif last_date_in_data.year >= 2025:
        forecast_start_date = last_date_in_data + pd.Timedelta(days=1)

    if forecast_start_date > forecast_end_date:
        print(f"  Warning: Forecast start date {forecast_start_date.strftime('%Y-%m-%d')} is after forecast end date {forecast_end_date.strftime('%Y-%m-%d')}. Skipping 2025 forecast.")
        forecast_results = pd.DataFrame()
    else:
        forecast_dates = pd.date_range(start=forecast_start_date, end=forecast_end_date, freq='D')
        forecast_df = pd.DataFrame(index=forecast_dates)

        # Populate features for forecast_df similar to X_train
        forecast_df['t'] = np.arange(X['t'].max() + 1, X['t'].max() + 1 + len(forecast_df))
        forecast_df['sin7'] = np.sin(2 * np.pi * forecast_df['t'] / 7)
        forecast_df['cos7'] = np.cos(2 * np.pi * forecast_df['t'] / 7)
        forecast_df['sin30'] = np.sin(2 * np.pi * forecast_df['t'] / 30)
        forecast_df['cos30'] = np.cos(2 * np.pi * forecast_df['t'] / 30)

        for col in ['Avg_Price', 'Total_Stock', 'Avg_Reorder_Threshold', 'Total_Budget', 'Avg_Store_Size', 'Avg_Promo_Code']:
            if col in daily.columns:
                forecast_df[col] = daily[col].iloc[-1]
            else:
                forecast_df[col] = 0

        forecast_df['dow'] = forecast_df.index.dayofweek
        forecast_df['month'] = forecast_df.index.month

        dow_dummies_forecast = pd.get_dummies(forecast_df['dow'], prefix='dow')
        mon_dummies_forecast = pd.get_dummies(forecast_df['month'], prefix='mon')

        # Align columns with X_train
        for col in [c for c in X_train.columns if c.startswith('dow_')]:
            if col not in dow_dummies_forecast.columns: dow_dummies_forecast[col] = 0
        for col in [c for c in X_train.columns if c.startswith('mon_')]:
            if col not in mon_dummies_forecast.columns: mon_dummies_forecast[col] = 0

        forecast_df = pd.concat([forecast_df, dow_dummies_forecast, mon_dummies_forecast], axis=1).copy()

        # For lag and rolling features, use the last actual values from daily or 0 if not enough history
        for lag in [1,7,14,30]:
            lag_col_name = f'lag_{lag}'
            if lag_col_name in features:
                if len(daily['Quantity_Sold']) >= lag:
                    forecast_df[lag_col_name] = daily['Quantity_Sold'].iloc[-lag]
                else:
                    forecast_df[lag_col_name] = 0

        for w in [7,14,30]:
            roll_col_name = f'roll_{w}'
            if roll_col_name in features:
                if len(daily['Quantity_Sold']) >= w + 1:
                    forecast_df[roll_col_name] = daily['Quantity_Sold'].rolling(w).mean().iloc[-1]
                else:
                    forecast_df[roll_col_name] = 0

        X_forecast = forecast_df[features].copy()
        y_forecast_2025 = best_model.predict(X_forecast)
        y_forecast_2025[y_forecast_2025 < 0] = 0

        forecast_results = pd.DataFrame(y_forecast_2025, index=forecast_dates, columns=['Forecasted_Quantity_Sold'])

    # --- Visualization ---
    fig, ax = plt.subplots(figsize=(14, 7))
    ax.plot(daily.index, daily['Quantity_Sold'], label='Actual Overall')
    ax.plot(daily.index[split:], y_pred, '--', label='LightGBM Forecast (Test Set)')
    if not forecast_results.empty:
        ax.plot(forecast_results.index, forecast_results['Forecasted_Quantity_Sold'], 'r-', label='Forecasted Sales 2025')

    ax.set_title(f'Actual vs Forecast (LightGBM) for {product_name}')
    ax.set_xlabel('Date')
    ax.set_ylabel('Quantity Sold')
    ax.legend()
    ax.grid(True, linestyle='--', alpha=0.6)
    plt.tight_layout()

    return fig, forecast_results
