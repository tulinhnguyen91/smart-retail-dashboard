# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eVk8fXsLXzXr51IbSTT6N2B7g5s_H8lr
"""

import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt

# Import functions from your modules
from utils.data_preprocessing import load_and_preprocess_data
from eda.visualizations import (
    plot_store_performance_ranking, plot_monthly_revenue, plot_total_units_sold_by_month,
    plot_quantity_sold_by_brand_per_store, plot_apple_vs_samsung_sales_by_year,
    plot_monthly_units_sold_by_performance_tier, plot_quantity_sold_by_location_tier,
    plot_performance_tier_distribution_by_location_tier,
    plot_promotion_activity_throughout_year, plot_promotion_type_frequency_by_brand,
    plot_monthly_promo_budget_vs_units_sold, plot_correlation_heatmap
)
from models.linear_regression import run_linear_regression_forecast
from models.prophet_model import run_prophet_forecast
from models.lstm_model import run_lstm_forecast
from models.lightgbm_model import run_lightgbm_forecast
from optimization.inventory_optimization import run_inventory_optimization
from optimization.supply_chain_optimization import run_supply_chain_optimization
from concept_drift.drift_detector import run_concept_drift_check

st.set_page_config(layout="wide", page_title="Hệ thống phân tích và dự báo bán hàng")

st.title("Hệ thống phân tích và dự báo bán hàng")

# --- Load Data (using Streamlit's caching) ---
@st.cache_data
def load_data():
    """Load and preprocess data, then save final_dataset.csv for other modules."""
    df_final = load_and_preprocess_data(
        transaction_path='data/transaction_data_2023_2024_updated.csv',
        promotion_path='data/promotion_data.csv',
        store_path='data/store_info_data_2023_2024_updated.csv'
    )
    if not df_final.empty:
        # Save to a temporary file or a known location for other modules to read if needed
        # For simplicity, we'll assume other modules can access 'df_final' directly if passed
        # or can re-load 'final_dataset.csv' if it's placed in 'data/'
        df_final.to_csv('data/final_dataset.csv', index=False) # Ensure this file exists for drift_detector
    return df_final

df_final = load_data()

if df_final.empty:
    st.error("Không thể tải hoặc xử lý dữ liệu. Vui lòng kiểm tra các file CSV trong thư mục `data/`.")
    st.stop() # Dừng ứng dụng nếu không có dữ liệu

df_transaction_for_eda = df_final.copy() # EDA functions might modify, so pass a copy

# --- Sidebar Navigation ---
st.sidebar.title("Navigation")
analysis_type = st.sidebar.radio(
    "Chọn loại phân tích:",
    ("Tổng quan dữ liệu", "Phân tích Khám phá (EDA)", "Dự báo Doanh số", "Tối ưu hóa", "Concept Drift")
)

# --- Main Content Area ---

if analysis_type == "Tổng quan dữ liệu":
    st.header("Tổng quan Dữ liệu")
    st.write("Dữ liệu đã được tải và tiền xử lý thành công.")
    st.subheader("5 dòng đầu tiên của dữ liệu cuối cùng:")
    st.dataframe(df_final.head())
    st.subheader("Thông tin tổng quan về dữ liệu:")
    buffer = io.StringIO()
    df_final.info(buf=buffer) # df.info() sẽ ghi thông tin vào 'buffer'
    s = buffer.getvalue()     # Lấy toàn bộ nội dung từ 'buffer' dưới dạng chuỗi
    st.text(s)                # Hiển thị chuỗi này trong Streamlit

    st.subheader("Thống kê mô tả:")
    st.dataframe(df_final.describe())

elif analysis_type == "Phân tích Khám phá (EDA)":
    st.header("Phân tích Khám phá Dữ liệu (EDA)")
    eda_option = st.selectbox(
        "Chọn biểu đồ EDA:",
        [
            "Xếp hạng hiệu suất cửa hàng theo số lượng bán",
            "Doanh thu hàng tháng",
            "Tổng số sản phẩm bán ra theo tháng",
            "Số lượng bán theo thương hiệu cho mỗi cửa hàng",
            "Tổng số sản phẩm Apple vs Samsung bán ra theo năm",
            "Xu hướng số lượng bán hàng tháng theo cấp hiệu suất cửa hàng",
            "Tổng và trung bình số lượng bán theo cấp độ vị trí cửa hàng",
            "Phân phối cấp hiệu suất theo cấp độ vị trí cửa hàng",
            "Hoạt động khuyến mãi trong năm",
            "Tần suất loại khuyến mãi theo thương hiệu",
            "Tương quan: Ngân sách khuyến mãi hàng tháng vs Số lượng bán",
            "Heatmap ma trận tương quan"
        ]
    )

    if eda_option == "Xếp hạng hiệu suất cửa hàng theo số lượng bán":
        st.subheader("Xếp hạng hiệu suất cửa hàng theo số lượng bán")
        fig = plot_store_performance_ranking(df_transaction_for_eda)
        st.pyplot(fig)
    elif eda_option == "Doanh thu hàng tháng":
        st.subheader("Doanh thu hàng tháng")
        fig = plot_monthly_revenue(df_final)
        st.pyplot(fig)
    elif eda_option == "Tổng số sản phẩm bán ra theo tháng":
        st.subheader("Tổng số sản phẩm bán ra theo tháng")
        fig = plot_total_units_sold_by_month(df_final)
        st.pyplot(fig)
    elif eda_option == "Số lượng bán theo thương hiệu cho mỗi cửa hàng":
        st.subheader("Số lượng bán theo thương hiệu cho mỗi cửa hàng")
        fig = plot_quantity_sold_by_brand_per_store(df_transaction_for_eda)
        st.pyplot(fig)
    elif eda_option == "Tổng số sản phẩm Apple vs Samsung bán ra theo năm":
        st.subheader("Tổng số sản phẩm Apple vs Samsung bán ra theo năm")
        fig = plot_apple_vs_samsung_sales_by_year(df_final)
        st.pyplot(fig)
    elif eda_option == "Xu hướng số lượng bán hàng tháng theo cấp hiệu suất cửa hàng":
        st.subheader("Xu hướng số lượng bán hàng tháng theo cấp hiệu suất cửa hàng")
        fig = plot_monthly_units_sold_by_performance_tier(df_final)
        st.pyplot(fig)
    elif eda_option == "Tổng và trung bình số lượng bán theo cấp độ vị trí cửa hàng":
        st.subheader("Tổng và trung bình số lượng bán theo cấp độ vị trí cửa hàng")
        fig1, fig2 = plot_quantity_sold_by_location_tier(df_transaction_for_eda)
        st.pyplot(fig1)
        st.pyplot(fig2)
    elif eda_option == "Phân phối cấp hiệu suất theo cấp độ vị trí cửa hàng":
        st.subheader("Phân phối cấp hiệu suất theo cấp độ vị trí cửa hàng")
        fig = plot_performance_tier_distribution_by_location_tier(df_final)
        st.pyplot(fig)
    elif eda_option == "Hoạt động khuyến mãi trong năm":
        st.subheader("Hoạt động khuyến mãi trong năm")
        fig = plot_promotion_activity_throughout_year(df_final)
        st.pyplot(fig)
    elif eda_option == "Tần suất loại khuyến mãi theo thương hiệu":
        st.subheader("Tần suất loại khuyến mãi theo thương hiệu")
        fig = plot_promotion_type_frequency_by_brand(df_final)
        st.pyplot(fig)
    elif eda_option == "Tương quan: Ngân sách khuyến mãi hàng tháng vs Số lượng bán":
        st.subheader("Tương quan: Ngân sách khuyến mãi hàng tháng vs Số lượng bán")
        fig = plot_monthly_promo_budget_vs_units_sold(df_final)
        st.pyplot(fig)
    elif eda_option == "Heatmap ma trận tương quan":
        st.subheader("Heatmap ma trận tương quan của các biến số")
        fig = plot_correlation_heatmap(df_final)
        st.pyplot(fig)

elif analysis_type == "Dự báo Doanh số":
    st.header("Dự báo Doanh số")
    product_names = df_final['Product_Name'].unique().tolist()
    selected_product = st.selectbox("Chọn sản phẩm để dự báo:", product_names)

    model_option = st.selectbox(
        "Chọn mô hình dự báo:",
        ("Linear Regression", "Prophet", "LSTM", "LightGBM")
    )

    if st.button("Chạy dự báo"):
        st.write(f"Đang chạy dự báo cho sản phẩm: **{selected_product}** bằng mô hình **{model_option}**...")
        fig = None
        forecast_df = pd.DataFrame()

        if model_option == "Linear Regression":
            fig, forecast_df = run_linear_regression_forecast(df_final, selected_product)
        elif model_option == "Prophet":
            fig, forecast_df = run_prophet_forecast(df_final, selected_product)
        elif model_option == "LSTM":
            # LSTM có thể mất nhiều thời gian hơn và yêu cầu tensorflow
            st.warning("Mô hình LSTM có thể mất nhiều thời gian để huấn luyện. Vui lòng chờ...")
            fig, forecast_df = run_lstm_forecast(df_final, selected_product)
        elif model_option == "LightGBM":
            fig, forecast_df = run_lightgbm_forecast(df_final, selected_product)

        if fig:
            st.pyplot(fig)
            st.subheader("Kết quả dự báo:")
            st.dataframe(forecast_df)
        else:
            st.error("Không thể tạo dự báo cho sản phẩm này. Vui lòng kiểm tra dữ liệu hoặc log lỗi.")

elif analysis_type == "Tối ưu hóa":
    st.header("Tối ưu hóa")
    optimization_option = st.selectbox(
        "Chọn loại tối ưu hóa:",
        ("Tối ưu tồn kho (Kho tổng -> Cửa hàng)", "Tối ưu chuỗi cung ứng (Cửa hàng -> Cửa hàng)")
    )

    if optimization_option == "Tối ưu tồn kho (Kho tổng -> Cửa hàng)":
        st.subheader("Tối ưu tồn kho từ kho tổng")
        warehouse_limit = st.number_input("Giới hạn cung cấp từ kho tổng (đơn vị):", min_value=1, value=1000)
        storage_cap = st.number_input("Sức chứa sản phẩm trên mỗi m² cửa hàng:", min_value=0.1, value=0.5)

        if st.button("Chạy tối ưu tồn kho"):
            st.write("Đang chạy tối ưu tồn kho...")
            # Pass df_final and df_store from the original loaded data
            df_store_info = pd.read_csv('data/store_info_data_2023_2024_updated.csv')
            results_df = run_inventory_optimization(df_final, df_store_info,
                                                    warehouse_supply_limit=warehouse_limit,
                                                    storage_capacity_per_sqm=storage_cap)
            if not results_df.empty:
                st.subheader("Kết quả tối ưu tồn kho:")
                st.dataframe(results_df[results_df['Adjustment_Units_From_Warehouse'] > 0].sort_values(by='Adjustment_Units_From_Warehouse', ascending=False))
                st.download_button(
                    label="Tải kết quả tối ưu tồn kho",
                    data=results_df.to_csv(index=False).encode('utf-8'),
                    file_name="inventory_optimization_results.csv",
                    mime="text/csv",
                )
            else:
                st.warning("Không có kết quả tối ưu tồn kho hoặc dữ liệu không đủ.")

    elif optimization_option == "Tối ưu chuỗi cung ứng (Cửa hàng -> Cửa hàng)":
        st.subheader("Tối ưu chuỗi cung ứng (Chuyển kho giữa các cửa hàng)")
        storage_cap_sc = st.number_input("Sức chứa sản phẩm trên mỗi m² cửa hàng:", min_value=0.1, value=0.5, key="sc_cap")
        unmet_penalty = st.number_input("Chi phí phạt cho nhu cầu không được đáp ứng:", min_value=1, value=1000, key="sc_penalty")

        if st.button("Chạy tối ưu chuỗi cung ứng"):
            st.write("Đang chạy tối ưu chuỗi cung ứng...")
            df_store_info = pd.read_csv('data/store_info_data_2023_2024_updated.csv')
            transfer_df, unmet_df, fig_sc = run_supply_chain_optimization(df_final, df_store_info,
                                                                          storage_capacity_per_sqm=storage_cap_sc,
                                                                          unmet_demand_penalty=unmet_penalty)
            if transfer_df is not None and not transfer_df.empty:
                st.subheader("Đề xuất chuyển kho giữa các cửa hàng:")
                st.dataframe(transfer_df)
                st.download_button(
                    label="Tải kết quả chuyển kho",
                    data=transfer_df.to_csv(index=False).encode('utf-8'),
                    file_name="supply_chain_transfers_results.csv",
                    mime="text/csv",
                )
                if fig_sc:
                    st.pyplot(fig_sc)
            else:
                st.info("Không có chuyển kho nào được đề xuất hoặc dữ liệu không đủ.")

            if unmet_df is not None and not unmet_df.empty:
                st.subheader("Nhu cầu còn thiếu sau tối ưu:")
                st.dataframe(unmet_df)
                st.download_button(
                    label="Tải tóm tắt nhu cầu không được đáp ứng",
                    data=unmet_df.to_csv(index=False).encode('utf-8'),
                    file_name="supply_chain_unmet_demand.csv",
                    mime="text/csv",
                )

elif analysis_type == "Concept Drift":
    st.header("Kiểm tra Concept Drift")
    st.write("Kiểm tra sự thay đổi trong phân phối dữ liệu 'Quantity_Sold' theo thời gian.")
    drift_split_date = st.text_input("Nhập ngày phân chia dữ liệu (YYYY-MM-DD):", value="2024-11-01")

    if st.button("Chạy kiểm tra Concept Drift"):
        # The run_concept_drift_check function directly uses st, so no need to return fig
        run_concept_drift_check(df_path='data/final_dataset.csv', split_date=drift_split_date)
